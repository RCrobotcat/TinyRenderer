```cpp
#include <random>
#include <algorithm>

#include "gl_mine.h"
#include "model.h"

extern mat<4, 4> Viewport, ModelView, Perspective; // "OpenGL" state matrices and
extern std::vector<double> zbuffer;     // the depth buffer

struct BlankShader : IShader {
    const Model &model;

    BlankShader(const Model &m) : model(m) {}

    virtual vec4 vertex(const int face, const int vert) {
        vec4 gl_Position = ModelView * model.vert(face, vert);
        return Perspective * gl_Position;
    }

    virtual std::pair<bool, TGAColor> fragment(const vec3 bar) const {
        return {false, {255, 255, 255, 255}};
    }
};

int main() {
    constexpr int width = 800;      // output image size
    constexpr int height = 800;
    constexpr vec3 eye{-1, 0, 2}; // camera position
    constexpr vec3 center{0, 0, 0}; // camera direction
    constexpr vec3 up{0, 1, 0}; // camera up vector

    // usual rendering pass
    lookat(eye, center, up);
    init_perspective(norm(eye - center));
    init_viewport(width / 16, height / 16, width * 7 / 8, height * 7 / 8);
    init_zbuffer(width, height);
    TGAImage framebuffer(width, height, TGAImage::RGB, {177, 195, 209, 255});

    Model model("../Obj/diablo3_pose.obj");
    BlankShader shader{model};
    for (int f = 0; f < model.nfaces(); f++) {      // iterate through all facets
        Triangle clip = {shader.vertex(f, 0),  // assemble the primitive
                         shader.vertex(f, 1),
                         shader.vertex(f, 2)};
        rasterize(clip, shader, framebuffer);   // rasterize the primitive
    }

    // SSAO pass => ä¸€èˆ¬åœ¨åå¤„ç†é˜¶æ®µ
    constexpr double ao_radius = .1;  // ssao ball radius in normalized device coordinates
    constexpr int nsamples = 128;     // number of samples in the ball
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dist(-ao_radius, ao_radius);
    auto smoothstep = [](double edge0, double edge1,
                         double x) {         // smoothstep returns 0 if the input is less than the left edge,
        double t = std::clamp((x - edge0) / (edge1 - edge0), 0., 1.);  // 1 if the input is greater than the right edge,
        return t * t * (3 - 2 * t);
        // Hermite interpolation inbetween. The derivative of the smoothstep function is zero at both edges.
    };

#pragma omp parallel for
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            double z = zbuffer[x + y * width];
            if (z < -100) continue;
            vec4 fragment = Viewport.invert() * vec4{static_cast<double>(x),
                                                     static_cast<double>(y), z,
                                                     1.}; // for each fragment in the framebuffer
            double vote = 0;
            double voters = 0;
            for (int i = 0; i < nsamples; i++) { // è®¡ç®—å½“å‰åƒç´ å‘¨å›´çš„nsamplesä¸ªç‚¹(çƒä½“åˆ†å¸ƒ) ç”¨äºè®¡ç®—ç¯å¢ƒå…‰é®è”½
                // compute a very rough approximation of the solid angle
                vec4 p = Viewport * (fragment + vec4{dist(gen), dist(gen), dist(gen), 0.});
                if (p.x < 0 || p.x >= width || p.y < 0 || p.y >= height) continue;
                double d = zbuffer[int(p.x) + int(p.y) * width];
                if (z + 5 * ao_radius < d) continue; // range check to remove the dark halo
                voters++;
                vote += d > p.z;
            }
            double ssao = smoothstep(0, 1, 1 - vote / voters * .4);
            TGAColor c = framebuffer.get(x, y);
            framebuffer.set(x, y, {static_cast<uint8_t>(c[0] * ssao),
                                   static_cast<uint8_t>(c[1] * ssao),
                                   static_cast<uint8_t>(c[2] * ssao), c[3]});
        }
    }

    framebuffer.write_tga_file("framebuffer.tga");
    return 0;
}

```

è¿™æ®µä»£ç å…¶å®æ˜¯ä¸€ä¸ªå®Œæ•´çš„ **åŸºäºæ·±åº¦ç¼“å†²çš„ SSAOï¼ˆScreen Space Ambient Occlusionï¼‰å®ç°**ã€‚
 ä¸‹é¢æˆ‘ä¼šæŒ‰ç…§æ‰§è¡Œé¡ºåºã€æ•°å­¦åŸç†ã€åæ ‡ç³»æ–¹å‘ï¼ˆä½ çš„æ˜¯ **z è¶Šå¤§è¶Šè¿‘**ï¼‰é€æ­¥è§£é‡Šï¼Œè®©ä½ èƒ½å®Œæ•´æŒæ¡æ•´ä¸ªç®—æ³•çš„æ„ä¹‰ä¸å®ç°é€»è¾‘ã€‚

------

# ä¸€ã€ä»£ç æ€»ä½“ç»“æ„

è¿™æ®µç¨‹åºä¸»è¦åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼š

| é˜¶æ®µ                 | åŠŸèƒ½                                                         |
| -------------------- | ------------------------------------------------------------ |
| **1. æ­£å¸¸æ¸²æŸ“ pass** | æ¸²æŸ“æ¨¡å‹å¹¶ç”Ÿæˆé¢œè‰²å¸§ç¼“å†²ï¼ˆ`framebuffer`ï¼‰å’Œæ·±åº¦ç¼“å†²ï¼ˆ`zbuffer`ï¼‰ |
| **2. SSAO pass**     | ä»…ä½¿ç”¨ `zbuffer`ï¼ˆå±å¹•ç©ºé—´æ·±åº¦ï¼‰ä¼°ç®—æ¯ä¸ªåƒç´ çš„ç¯å¢ƒå…‰é®è”½ç¨‹åº¦ï¼Œç„¶åè®©è¢«é®æŒ¡åŒºåŸŸå˜æš— |

è¾“å‡ºç»“æœæ˜¯ä¸€å¼ å¸¦æœ‰è‡ªç„¶é˜´å½±çš„ç°åº¦æˆ–å½©è‰²å›¾åƒï¼Œé˜´å½±é›†ä¸­åœ¨å‡ ä½•ä½“çš„ç¼éš™ã€æ¥è§¦é¢å’Œå‡¹é™·å¤„ã€‚

------

# äºŒã€å‰åŠéƒ¨åˆ†ï¼šæ ‡å‡†æ¸²æŸ“é˜¶æ®µ

```cpp
lookat(eye, center, up);
init_perspective(norm(eye - center));
init_viewport(width / 16, height / 16, width * 7 / 8, height * 7 / 8);
init_zbuffer(width, height);
```

- è¿™å‡ è¡Œè®¾ç½®äº†è™šæ‹Ÿç›¸æœºçš„è§‚å¯ŸçŸ©é˜µï¼ˆ`ModelView`ï¼‰ã€é€è§†çŸ©é˜µï¼ˆ`Perspective`ï¼‰ã€è§†å£çŸ©é˜µï¼ˆ`Viewport`ï¼‰ï¼›

- `zbuffer` åˆå§‹åŒ–ä¸ºè¿œå¹³é¢ï¼ˆé€šå¸¸ä¸º -âˆ æˆ–å¾ˆå°çš„è´Ÿæ•°ï¼‰ï¼›

- æ¸²æŸ“å¾ªç¯ï¼š

  ```cpp
  for (each face f in model)
      rasterize(shader.vertex(f,0), shader.vertex(f,1), shader.vertex(f,2))
  ```

  æ¯ä¸ªä¸‰è§’å½¢ç»è¿‡é¡¶ç‚¹å˜æ¢ â†’ å…‰æ …åŒ– â†’ æ›´æ–° `framebuffer` å’Œ `zbuffer`ã€‚

ç»“æœï¼š

- `framebuffer` ä¿å­˜é¢œè‰²ï¼›
- `zbuffer` ä¿å­˜æ¯ä¸ªåƒç´ çš„æ·±åº¦ï¼ˆâš ï¸**ä½ çš„æ·±åº¦å®šä¹‰æ˜¯ï¼šè¶Šå¤§è¶Šé è¿‘ç›¸æœº**ï¼‰ã€‚

------

# ä¸‰ã€SSAO çš„ç†è®ºåŸç†

SSAOï¼ˆå±å¹•ç©ºé—´ç¯å¢ƒå…‰é®è”½ï¼‰æ˜¯ä¸€ç§å¿«é€Ÿçš„è¿‘ä¼¼æ–¹æ³•ï¼Œç”¨æ¥ä¼°è®¡ä¸€ä¸ªåƒç´ è¢«å‘¨å›´å‡ ä½•ä½“â€œæŒ¡ä½å¤©ç©ºâ€çš„ç¨‹åº¦ã€‚

ç›´è§‰ï¼š

- å¦‚æœæŸåƒç´ é™„è¿‘çš„å…¶ä»–åƒç´ æ¯”å®ƒ**æ›´é è¿‘ç›¸æœºï¼ˆz æ›´å¤§ï¼‰**ï¼Œè¯´æ˜è¿™ä¸ªæ–¹å‘ä¸Šæœ‰é®æŒ¡ï¼›
- å¦‚æœå‘¨å›´éƒ½æ˜¯æ›´è¿œçš„ï¼ˆz æ›´å°ï¼‰ï¼Œè¯´æ˜è¯¥åƒç´ æš´éœ²åœ¨å¤–ï¼Œæ²¡æœ‰é®æŒ¡ã€‚

é®è”½æ¯”ä¾‹è¶Šå¤§ â†’ å…‰çº¿ç…§ä¸è¿›æ¥ â†’ æ›´æš—ã€‚

------

# å››ã€ä½ çš„ SSAO å®ç°ç»†èŠ‚

------

## (1) è®¾ç½®å‚æ•°å’Œéšæœºåˆ†å¸ƒ

```cpp
constexpr double ao_radius = .1;   // é‡‡æ ·çƒä½“åŠå¾„ï¼ˆNDCç©ºé—´ï¼‰
constexpr int nsamples = 128;      // é‡‡æ ·æ¬¡æ•°
std::uniform_real_distribution<double> dist(-ao_radius, ao_radius);
```

- æ¯ä¸ªåƒç´ å‘¨å›´é‡‡æ ·ä¸€ä¸ªåŠå¾„ä¸º `0.1` çš„çƒä½“ï¼›
- ç”¨ `dist(gen)` ç”Ÿæˆ `[âˆ’0.1, 0.1]` çš„éšæœºåç§»ï¼›
- å…±é‡‡æ · 128 ä¸ªéšæœºæ–¹å‘ã€‚

è¿™æ ·å°±èƒ½åœ¨å±å¹•ç©ºé—´çš„å±€éƒ¨åŒºåŸŸè¿›è¡Œâ€œéšæœºæ¢æµ‹â€ã€‚

------

## (2) åå˜æ¢åˆ° NDC ç©ºé—´

```cpp
vec4 fragment = Viewport.invert() * vec4{x, y, z, 1.};
```

- `(x, y, z)` æ˜¯å±å¹•ç©ºé—´åæ ‡ï¼›
- `Viewport.invert()` æŠŠå®ƒä»å±å¹•ç©ºé—´å˜å›åˆ° **NDCï¼ˆNormalized Device Coordinatesï¼‰ç©ºé—´**ï¼›
- `fragment` è¡¨ç¤ºå½“å‰åƒç´ åœ¨ä¸‰ç»´ç©ºé—´ä¸­çš„è¿‘ä¼¼ä½ç½®ã€‚

------

## (3) ç”Ÿæˆéšæœºé‡‡æ ·ç‚¹å¹¶æŠ•å½±å›å±å¹•

```cpp
vec4 p = Viewport * (fragment + vec4{dist(gen), dist(gen), dist(gen), 0.});
```

- åœ¨å½“å‰ç‰‡å…ƒå‘¨å›´éšæœºç”Ÿæˆä¸€ä¸ªç‚¹ `p`ï¼ˆä¸‰ç»´åç§»å‘é‡ï¼‰ï¼›
- ç„¶åä¹˜ä¸Š `Viewport`ï¼ŒæŠŠå®ƒé‡æ–°æ˜ å°„å›å±å¹•åæ ‡ç³»ï¼ˆä»¥ä¾¿èƒ½æŸ¥ zbufferï¼‰ã€‚

------

## (4) æ·±åº¦é‡‡æ ·ä¸é®æŒ¡åˆ¤æ–­

```cpp
double d = zbuffer[int(p.x) + int(p.y) * width];
if (z + 5 * ao_radius < d) continue;  // è¿‡æ»¤è¿œå¤„å·®å¼‚è¿‡å¤§çš„ç‚¹
voters++;
vote += d > p.z;
```

é€è¡Œè§£é‡Šï¼š

### âœ… æ·±åº¦æ–¹å‘å«ä¹‰ï¼ˆä½ çš„åæ ‡ç³»ï¼‰

> **z è¶Šå¤§ = è¶Šè¿‘ç›¸æœºï¼Œz è¶Šå° = è¶Šè¿œã€‚**

### åˆ¤æ–­é€»è¾‘

1. `d`ï¼šä» zbuffer å–å‡ºçš„å±å¹•æ·±åº¦å€¼ â†’ è¡¨ç¤ºå±å¹•ä¸Šè¯¥ä½ç½®çš„å¯è§è¡¨é¢è·ç¦»ç›¸æœºçš„æ·±æµ…ï¼›
2. `p.z`ï¼šé‡‡æ ·ç‚¹çš„æ·±åº¦ï¼›
3. `d > p.z` â†’ å±å¹•ä¸Šæœ‰æ›´è¿‘çš„å‡ ä½•ä½“æŒ¡ä½è¯¥æ–¹å‘ï¼›
   - âœ… è¡¨ç¤ºâ€œè¢«é®æŒ¡â€ï¼›
4. `z + 5 * ao_radius < d` â†’ é‡‡æ ·ç‚¹ç¦»å½“å‰åƒç´ å¤ªè¿œï¼ˆæ·±åº¦å·®å¤ªå¤§ï¼‰ï¼Œè·³è¿‡ï¼›
   - ç”¨æ¥é˜²æ­¢é»‘è¾¹â€œå…‰æ™•ï¼ˆhaloï¼‰â€æ•ˆåº”ï¼›
5. `vote` ç»Ÿè®¡â€œè¢«é®æŒ¡çš„æ¬¡æ•°â€ï¼Œ`voters` ç»Ÿè®¡æœ‰æ•ˆæ ·æœ¬æ•°ã€‚

------

## (5) è®¡ç®—é®è”½æ¯”ä¾‹å¹¶å¹³æ»‘åŒ–

```cpp
double ssao = smoothstep(0, 1, 1 - vote / voters * .4);
```

å®šä¹‰ï¼š
$$
\text{occlusion} = \frac{\text{vote}}{\text{voters}}
$$
 â†’ è¢«é®æŒ¡çš„æ¯”ä¾‹ã€‚

å¹³æ»‘å¤„ç†ï¼š
$$
SSAO = \text{smoothstep}(0,1,1 - 0.4\times\text{occlusion})
$$
å…¶ä¸­ smoothstepï¼š
$$
\text{smoothstep}(a,b,x)=
 \begin{cases}
 0,&x<a\\
 3t^2-2t^3,&a\le x\le b,\ t=\frac{x-a}{b-a}\\
 1,&x>b
 \end{cases}
$$
ä½œç”¨ï¼š

- è®©äº®åº¦å˜åŒ–æ›´å¹³æ»‘ï¼›
- é¿å…â€œç¡¬è¾¹â€é˜´å½±ã€‚

------

## (6) æ ¹æ® SSAO è°ƒæ•´åƒç´ äº®åº¦

```cpp
TGAColor c = framebuffer.get(x, y);
framebuffer.set(x, y, {
    uint8_t(c[0] * ssao),
    uint8_t(c[1] * ssao),
    uint8_t(c[2] * ssao),
    c[3]
});
```

ä¹˜ä¸Š `ssao` ç³»æ•°åï¼š

- è‹¥ `ssao` æ¥è¿‘ 1 â†’ æ˜äº®ï¼›
- è‹¥ `ssao` å°ï¼ˆè¢«é®æŒ¡å¤šï¼‰â†’ å˜æš—ã€‚

æœ€ç»ˆå¾—åˆ°çš„å›¾åƒåŒ…å«å±€éƒ¨é˜´å½±ä¿¡æ¯ï¼Œå¢å¼ºç«‹ä½“æ„Ÿã€‚

------

# äº”ã€æ•´ä½“æµç¨‹æ€»ç»“

| é˜¶æ®µ      | å…¬å¼ / æ“ä½œ                                | è¯´æ˜                |
| --------- | ------------------------------------------ | ------------------- |
| æ¸²æŸ“ pass | ç”Ÿæˆé¢œè‰²ç¼“å†² + æ·±åº¦ç¼“å†²                    | å¾—åˆ°æ¯ä¸ªåƒç´ çš„ z å€¼ |
| åæŠ•å½±    | ( fragment = V^{-1}(x,y,z) )               | å±å¹•ç‚¹â†’NDC ç©ºé—´     |
| éšæœºé‡‡æ ·  | ( p = fragment + \text{rand}(-r,r) )       | å±€éƒ¨éšæœºæ‰°åŠ¨        |
| æ·±åº¦æ¯”è¾ƒ  | è‹¥ ( d > p_z )ï¼Œåˆ™æ–¹å‘è¢«é®æŒ¡               | ç»Ÿè®¡è¢«é®æŒ¡æ–¹å‘      |
| é®è”½ç‡    | ( \text{AO} = 1 - 0.4\times(vote/voters) ) | é®æŒ¡è¶Šå¤šè¶Šæš—        |
| å¹³æ»‘å¤„ç†  | ( SSAO = smoothstep(0,1,AO) )              | æŸ”åŒ–è¿‡æ¸¡            |
| è°ƒæ•´äº®åº¦  | ( C' = C\times SSAO )                      | åº”ç”¨é˜´å½±æ•ˆæœ        |

------

# å…­ã€å‡ ä½•ç›´è§‰ï¼ˆåŸºäº z è¶Šå¤§è¶Šè¿‘çš„å®šä¹‰ï¼‰

ä¸‹å›¾æ¦‚å¿µï¼ˆæ–‡å­—ç‰ˆï¼‰ï¼š

```
ç›¸æœº
  â†‘
  â”‚
  â”‚ z å¢å¤§ï¼ˆæ›´è¿‘ï¼‰
  â”‚
  â”œâ”€â”€ ç‚¹ P (å½“å‰åƒç´ )
  â”‚ \
  â”‚  \
  â”‚   Â·  â† é‡‡æ ·ç‚¹ (p)
  â”‚    \
  â”‚     â—  â† å‰æ–¹å‡ ä½•ä½“ï¼ˆd>p.zï¼‰
  â†“
```

åœ¨è¯¥æ–¹å‘ä¸Šï¼š

- å¦‚æœå­˜åœ¨â€œå‰æ–¹å‡ ä½•ä½“â€ â†’ è¯¥æ–¹å‘è¢«é®æŒ¡ï¼›
- å¦‚æœä¸€ç›´é€šå‘è¿œå¤„ï¼ˆz å˜å°ï¼‰ â†’ è¯¥æ–¹å‘å¼€æ”¾ã€‚

å¤šä¸ªæ–¹å‘é‡‡æ ·åå³å¯ä¼°ç®— AOã€‚

------

# âœ… ä¸ƒã€æ€»ç»“ä¸€å¥è¯

> è¿™æ®µä»£ç é€šè¿‡å¯¹æ¯ä¸ªåƒç´ çš„æ·±åº¦å€¼è¿›è¡Œ**å±€éƒ¨éšæœºé‡‡æ ·å’Œæ·±åº¦æ¯”è¾ƒ**ï¼Œç»Ÿè®¡è¢«é®æŒ¡çš„æ¯”ä¾‹ï¼Œå¹¶é€šè¿‡ `smoothstep` å¹³æ»‘åŒ–ï¼Œæœ€ç»ˆè®©å‡¹é™·å¤„æˆ–æ¥è§¦å¤„å˜æš—ï¼Œå®ç°äº†**åŸºäºå±å¹•ç©ºé—´çš„ç¯å¢ƒå…‰é®è”½ï¼ˆSSAOï¼‰æ•ˆæœ**ã€‚
>  åœ¨ä½ çš„å®ç°ä¸­ï¼Œ**z è¶Šå¤§è¡¨ç¤ºè¶Šé è¿‘ç›¸æœº**ï¼Œå› æ­¤åˆ¤æ–­ `d > p.z` è¡¨ç¤ºå½“å‰æ–¹å‘è¢«é®æŒ¡ã€‚



---

å¾ˆå¤šåšæ¸²æŸ“æˆ–å›¾å½¢å­¦çš„åŒå­¦åœ¨ç¬¬ä¸€æ¬¡æ¥è§¦ SSAO æ—¶éƒ½ä¼šé—®çš„ï¼š

> â€œæˆ‘å·²ç»æœ‰ Blinn-Phong æˆ– PBR å…‰ç…§æ¨¡å‹äº†ï¼Œå®ƒä¸æ˜¯ä¹Ÿæœ‰ç¯å¢ƒå…‰ï¼ˆambientï¼‰åˆ†é‡å—ï¼Ÿ
> ä¸ºä»€ä¹ˆè¿˜è¦åŠ ä¸€ä¸ª SSAOï¼ˆScreen Space Ambient Occlusionï¼‰ï¼Ÿâ€

ä¸‹é¢æˆ‘ä» **ç‰©ç†æ„ä¹‰ â†’ å…‰ç…§æ¨¡å‹å±€é™ â†’ SSAO çš„è¡¥å……ä½œç”¨** ä¸‰ä¸ªå±‚é¢è§£é‡Šç»™ä½ ğŸ‘‡

---

## ğŸŒ ä¸€ã€å…‰ç…§æ¨¡å‹çš„ç»„æˆï¼šç¯å¢ƒå…‰åªæ˜¯â€œå¹³å‡å€¼â€

åƒ **Phong**ã€**Blinn-Phong**ã€**PBR** ç­‰å…‰ç…§æ¨¡å‹ï¼Œé€šå¸¸æŠŠå…¥å°„å…‰åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼š

$$
I = I_\text{ambient} + I_\text{diffuse} + I_\text{specular}
$$
å…¶ä¸­ï¼š

* **ç¯å¢ƒå…‰ï¼ˆambientï¼‰**ï¼šè¡¨ç¤ºâ€œæ¥è‡ªå››é¢å…«æ–¹çš„é—´æ¥å…‰â€ï¼Œé€šå¸¸æ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œæ¯”å¦‚
  $$
  I_\text{ambient} = k_a \cdot L_a
  $$
  ï¼ˆ`k_a` ä¸ºæè´¨ç³»æ•°ï¼Œ`L_a` ä¸ºå…¨å±€ç¯å¢ƒäº®åº¦ï¼‰

ğŸ‘‰ å®ƒæ˜¯å‡è®¾**æ¯ä¸ªè¡¨é¢ç‚¹éƒ½èƒ½å¹³å‡åœ°æ¥æ”¶åˆ°ç¯å¢ƒå…‰**ï¼Œ
**ä¸ä¼šè€ƒè™‘è¢«å‘¨å›´ç‰©ä½“é®æŒ¡**ã€‚

---

## ğŸŒ’ äºŒã€ç°å®ä¸–ç•Œä¸­ï¼šç¯å¢ƒå…‰ä¸æ˜¯å‡åŒ€åˆ†å¸ƒçš„

åœ¨ç°å®ä¸­ï¼Œâ€œç¯å¢ƒå…‰â€å…¶å®æ˜¯ä»å„ä¸ªæ–¹å‘åå°„è€Œæ¥çš„**é—´æ¥å…‰**ï¼Œè€Œä¸æ˜¯å‡åŒ€ç…§å°„ã€‚

ä¸¾ä¸ªä¾‹å­ğŸ‘‡

* æ¡Œé¢ä¸Šä¸€ä¸ªçƒï¼šé¡¶éƒ¨è¢«å¤©ç©ºç…§äº® â†’ æ˜äº®ï¼›
* åº•éƒ¨é è¿‘æ¡Œé¢ â†’ å…‰çº¿è¢«æŒ¡ â†’ æš—ï¼›
* å‡¹é™·ã€ç¼éš™å¤„ â†’ å‘¨å›´é®æŒ¡ä¸¥é‡ â†’ å‡ ä¹æ²¡æœ‰ç¯å¢ƒå…‰ â†’ å¾ˆæš—ã€‚

è¿™ç§**é®æŒ¡ç¯å¢ƒå…‰çš„å±€éƒ¨é˜´å½±**ï¼Œå°±æ˜¯ **Ambient Occlusionï¼ˆAOï¼‰**ï¼š

> AO è¡¨ç¤ºä¸€ä¸ªç‚¹åœ¨å¤šå¤§ç¨‹åº¦ä¸Šèƒ½â€œçœ‹åˆ°å¤©ç©ºâ€æˆ–â€œæ¥æ”¶åˆ°ç¯å¢ƒå…‰â€ã€‚

---

## ğŸ§± ä¸‰ã€å…‰ç…§æ¨¡å‹çš„ç¼ºé™·

Phong / Blinn-Phong / PBR æœ¬èº«éƒ½ä¸å¤„ç†å±€éƒ¨é®æŒ¡ã€‚
å®ƒä»¬åªä¼šåšï¼š

* ç‚¹å…‰æºæ–¹å‘è®¡ç®—æ¼«åå°„ï¼›
* æ–¹å‘å…‰è®¡ç®—é•œé¢åå°„ï¼›
* ç¯å¢ƒå…‰é¡¹æ’å®šã€‚

ç»“æœå°±æ˜¯ï¼š

> å³ä½¿ä¸¤ä¸ªç‰©ä½“éå¸¸è´´è¿‘ï¼ˆæ¯”å¦‚å¢™è§’ã€è¡£è¤¶ï¼‰ï¼Œåœ¨æ¨¡å‹å…‰ç…§ä¸‹ä¹ŸåŒæ ·äº®ï¼Œæ²¡æœ‰é‚£ç§çœŸå®çš„â€œæ¥è§¦é˜´å½±â€ã€‚

---

## ğŸ’¡ å››ã€SSAO çš„ä½œç”¨ï¼ˆå±å¹•ç©ºé—´ç¯å¢ƒå…‰é®è”½ï¼‰

SSAOï¼ˆScreen Space Ambient Occlusionï¼‰æ­£æ˜¯ç”¨æ¥è¡¥ä¸Šè¿™å—â€œç¯å¢ƒå…‰ä¸å‡åŒ€â€é—®é¢˜çš„ã€‚

* å®ƒé€šè¿‡åˆ†ææ·±åº¦ç¼“å†²ï¼ˆzbufferï¼‰æ¨æµ‹å‡ ä½•å½¢çŠ¶çš„é®æŒ¡ç¨‹åº¦ï¼›
* æ¨¡æ‹Ÿä¸€ä¸ªç‚¹çš„**ç¯å¢ƒå…‰æ¥æ”¶ç‡ï¼ˆvisibilityï¼‰**ï¼›
* ç»“æœæ˜¯ä¸€ä¸ªç°åº¦é®è”½ç³»æ•° ( $A(x,y) \in [0,1]$ )ï¼›
* åœ¨æœ€ç»ˆæ¸²æŸ“æ—¶ï¼š
  $$
  I_\text{final} = (I_\text{ambient} + I_\text{diffuse} + I_\text{specular}) \times A(x,y)
  $$

äºæ˜¯ï¼š

* å‡¹é™·å¤„ã€ç¼éš™ã€æ¥è§¦é¢ â†’ ($A(x,y)$) å° â†’ æš—ï¼›
* å¹³æ»‘ã€å¼€æ”¾è¡¨é¢ â†’ ($A(x,y)$) è¿‘ 1 â†’ äº®ï¼›
* æ•´ä¸ªåœºæ™¯ç«‹ä½“æ„Ÿå¢å¼ºï¼Œç©ºé—´å…³ç³»æ›´çœŸå®ã€‚

---

## ğŸ” äº”ã€ä¸¤è€…çš„å…³ç³»ï¼ˆå¯¹æ¯”æ€»ç»“ï¼‰

| é¡¹ç›®     | ç¯å¢ƒå…‰ (Ambient Term) | ç¯å¢ƒå…‰é®è”½ (AO / SSAO) |
| ------ | ------------------ | ----------------- |
| å«ä¹‰     | æ¨¡æ‹Ÿå…¨å±€å¹³å‡é—´æ¥å…‰          | æ¨¡æ‹Ÿå±€éƒ¨ç¯å¢ƒå…‰è¢«é®æŒ¡çš„ç¨‹åº¦     |
| æ¥æº     | å…‰ç…§æ¨¡å‹å…¬å¼ä¸­çš„å¸¸é‡é¡¹        | åå¤„ç†é˜¶æ®µæˆ–ç‹¬ç«‹ AO pass  |
| æ˜¯å¦è€ƒè™‘é®æŒ¡ | âŒ å¦                | âœ… æ˜¯               |
| è®¡ç®—æ–¹å¼   | å¸¸æ•°æˆ–è´´å›¾              | æ·±åº¦é‡‡æ ·ï¼ˆå±å¹•ç©ºé—´ï¼‰        |
| ç»“æœæ•ˆæœ   | å…¨å±€äº®åº¦è¡¥å¿             | å±€éƒ¨é˜´å½±å¢å¼º            |
| åœ¨æœ€ç»ˆå›¾åƒä¸­ | åŸºç¡€äº®åº¦               | ä¿®æ­£ã€è°ƒåˆ¶ç¯å¢ƒäº®åº¦         |

---

## ğŸ¨ å…­ã€æ•ˆæœå¯¹æ¯”

| åœºæ™¯     | ä»…å…‰ç…§æ¨¡å‹   | åŠ ä¸Š SSAO   |
| ------ | ------- | --------- |
| ç‰©ä½“æ¥è§¦åœ°é¢ | çœ‹ä¸åˆ°æ¥è§¦é˜´å½± | æœ‰è‡ªç„¶çš„æ¥è§¦é˜´å½±  |
| å‡¹é™·åŒºåŸŸ   | äº®åº¦ä¸å˜    | æ˜æ˜¾å˜æš—ã€æœ‰æ·±åº¦æ„Ÿ |
| æ•´ä½“ç«‹ä½“æ„Ÿ  | ç¨æ˜¾â€œæ¼‚æµ®â€  | ç©ºé—´å…³ç³»æ¸…æ™°ã€çœŸå® |

---

## âœ… ä¸ƒã€æ€»ç»“ä¸€å¥è¯

> å…‰ç…§æ¨¡å‹çš„â€œç¯å¢ƒå…‰â€åªæ˜¯å…¨å±€å¸¸é‡ï¼Œä¸è€ƒè™‘é®æŒ¡ï¼›
> **SSAO æ˜¯å¯¹ç¯å¢ƒå…‰é¡¹çš„å±€éƒ¨ä¿®æ­£**ï¼Œç”¨å±å¹•ç©ºé—´æ·±åº¦ä¿¡æ¯ä¼°è®¡æ¯ä¸ªåƒç´ è¢«é®æŒ¡çš„ç¨‹åº¦ï¼Œ
> ä½¿åœºæ™¯åœ¨æ¥è§¦é¢ã€ç¼éš™ã€å‡¹é™·å¤„å˜æš—ï¼Œæ›´ç¬¦åˆç°å®ä¸­çš„é—´æ¥å…‰åˆ†å¸ƒã€‚
