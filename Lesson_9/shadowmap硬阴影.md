```c++
#include <algorithm>
#include <cmath>
#include <vector>
#include "geometry.h"
#include "gl_mine.h"
#include "model.h"
#include "tgaimage.h"

extern mat<4, 4> ModelView, Perspective, Viewport;
extern std::vector<double> zbuffer;

struct BlankShader : IShader {
    const Model &model;

    BlankShader(const Model &m) : model(m) {}

    virtual vec4 vertex(const int face, const int vert) {
        vec4 gl_Position = ModelView * model.vert(face, vert);
        return Perspective * gl_Position;
    }

    virtual std::pair<bool, TGAColor> fragment(const vec3 bar) const {
        return {false, {255, 255, 255, 255}};
    }
};

struct BlinnPhongShader : IShader {
    const Model &model;
    vec4 l; // light direction in eye coordinates
    vec4 eye; // eye direction in eye coordinates
    vec2 varying_uv[3];  // triangle uv coordinates, written by the vertex shader, read by the fragment shader
    vec4 varying_nrm[3]; // normal per vertex to be interpolated by the fragment shader
    vec4 tri[3];         // triangle in view coordinates

    BlinnPhongShader(const vec3 light, const vec3 _eye, const Model &m) : model(m) {
        l = normalized((ModelView * vec4{light.x, light.y, light.z, 0.}));
        eye = normalized((ModelView * vec4{_eye.x, _eye.y, _eye.z, 0}));
    }

    virtual vec4 vertex(const int face, const int vert) {
        vec4 v = model.vert(face, vert); // current vertex in object coordinates
        vec4 gl_Position = ModelView * v; // transform it to screen coordinates

        tri[vert] = gl_Position;
        varying_uv[vert] = model.uv(face, vert); // uv coordinates
        varying_nrm[vert] = ModelView.invert_transpose() * model.normal(face, vert);

        return Perspective * gl_Position; // in clip coordinates
    }

    virtual std::pair<bool, TGAColor> fragment(const vec3 bar) const {
        // TBN matrix
        mat<2, 4> E = {tri[1] - tri[0], tri[2] - tri[0]};
        mat<2, 2> U = {varying_uv[1] - varying_uv[0], varying_uv[2] - varying_uv[0]};
        mat<2, 4> T = U.invert() * E;
        mat<4, 4> D = {normalized(T[0]),  // tangent vector
                       normalized(T[1]),  // bitangent vector
                       normalized(varying_nrm[0] * bar[0] + varying_nrm[1] * bar[1] +
                                  varying_nrm[2] * bar[2]), // interpolated normal
                       {0, 0, 0, 1}}; // Darboux frame

        vec2 uv = varying_uv[0] * bar.x + varying_uv[1] * bar.y + varying_uv[2] * bar.z; // interpolate uv coordinates
        vec4 n = normalized(D.transpose() * model.normal(uv));
        vec4 h = normalized(l + eye); // half vector
        double ambient = .5; // ambient light intensity
        double diff = std::max(0., n * l); // diffuse light intensity
        double spec = std::pow(std::max(n * h, 0.), 70);
        // specular intensity, note that the camera lies on the z-axis (in eye coordinates), therefore simple r.z, since (0,0,1)*(r.x, r.y, r.z) = r.z
        spec *= (3. * sample2D(model.specular(), uv)[0] / 255.);
        TGAColor gl_FragColor = sample2D(model.diffuse(), uv);
        for (int channel: {0, 1, 2}) {
            gl_FragColor[channel] = std::min<int>(255, gl_FragColor[channel] * (ambient + diff + spec));
        }
        return {false, gl_FragColor}; // do not discard the pixel
    }
};

// Ëé∑ÂèñÂπ∂‰øùÂ≠òz-buffer
void drop_zbuffer(std::string filename, std::vector<double> &zbuffer, int width, int height) {
    TGAImage zimg(width, height, TGAImage::GRAYSCALE, {0, 0, 0, 0});
    double minz = +1000;
    double maxz = -1000;
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            double z = zbuffer[x + y * width];
            if (z < -100) continue;
            minz = std::min(z, minz);
            maxz = std::max(z, maxz);
        }
    }
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            double z = zbuffer[x + y * width];
            if (z < -100) continue;
            z = (z - minz) / (maxz - minz) * 255;
            zimg.set(x, y, {(uint8_t) z, 255, 255, 255});
        }
    }
    zimg.write_tga_file(filename);
}

int main() {
    constexpr int width = 800;    // ËæìÂá∫ÂõæÂÉèÂ§ßÂ∞è
    constexpr int height = 800;
    constexpr int shadoww = 8000;   // shadow map ÂàÜËæ®Áéá
    constexpr int shadowh = 8000;
    constexpr vec3 light_dir{1, 1, 1};  // ÂÖâÊ∫êÊñπÂêë/‰ΩçÁΩÆ
    constexpr vec3 eye{-1, 0, 2};       // Áõ∏Êú∫‰ΩçÁΩÆ
    constexpr vec3 center{0, 0, 0};     // Áõ∏Êú∫ÁõÆÊ†á
    constexpr vec3 up{0, 1, 0};         // Áõ∏Êú∫‰∏äÊñπÂêë

    // ----------- ÊôÆÈÄöÊ∏≤Êüì pass -----------
    lookat(eye, center, up);
    init_perspective(norm(eye - center));
    init_viewport(width / 16, height / 16, width * 7 / 8, height * 7 / 8);
    init_zbuffer(width, height);
    TGAImage framebuffer(width, height, TGAImage::RGB, {177, 195, 209, 255});

    // Âõ∫ÂÆöÊ®°ÂûãË∑ØÂæÑ
    Model model_head("../Obj/diablo3_pose.obj");
    Model model_floor("../Obj/floor.obj");

    {   // head
        BlinnPhongShader shader(light_dir, eye, model_head);
        for (int f = 0; f < model_head.nfaces(); f++) {
            Triangle clip = {
                    shader.vertex(f, 0),
                    shader.vertex(f, 1),
                    shader.vertex(f, 2)
            };
            rasterize(clip, shader, framebuffer);
        }
    }
    {   // floor
        BlinnPhongShader shader(light_dir, eye, model_floor);
        for (int f = 0; f < model_floor.nfaces(); f++) {
            Triangle clip = {
                    shader.vertex(f, 0),
                    shader.vertex(f, 1),
                    shader.vertex(f, 2)
            };
            rasterize(clip, shader, framebuffer);
        }
    }
    framebuffer.write_tga_file("framebuffer.tga");
    drop_zbuffer("zbuffer1.tga", zbuffer, width, height);

    // ----------- Shadow map Ê∏≤Êüì pass -----------
    std::vector<bool> mask(width * height, false);
    std::vector<double> zbuffer_copy = zbuffer;
    mat<4, 4> M = (Viewport * Perspective * ModelView).invert();

    {
        lookat(light_dir, center, up);
        init_perspective(norm(light_dir - center));
        init_viewport(shadoww / 16, shadowh / 16, shadoww * 7 / 8, shadowh * 7 / 8);
        init_zbuffer(shadoww, shadowh);
        TGAImage trash(shadoww, shadowh, TGAImage::RGB, {177, 195, 209, 255});

        {   // head
            BlankShader shader{model_head};
            for (int f = 0; f < model_head.nfaces(); f++) {
                Triangle clip = {
                        shader.vertex(f, 0),
                        shader.vertex(f, 1),
                        shader.vertex(f, 2)
                };
                rasterize(clip, shader, trash);
            }
        }
        {   // floor
            BlankShader shader{model_floor};
            for (int f = 0; f < model_floor.nfaces(); f++) {
                Triangle clip = {
                        shader.vertex(f, 0),
                        shader.vertex(f, 1),
                        shader.vertex(f, 2)
                };
                rasterize(clip, shader, trash);
            }
        }

        trash.write_tga_file("shadowmap.tga");
    }
    drop_zbuffer("zbuffer2.tga", zbuffer, shadoww, shadowh);

    // ----------- ÂêéÂ§ÑÁêÜ pass -----------
    mat<4, 4> N = Viewport * Perspective * ModelView;
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            vec4 fragment = M * vec4{static_cast<double>(x), static_cast<double>(y),
                                     zbuffer_copy[x + y * width], 1.};
            vec4 q = N * fragment;
            vec3 p = q.xyz() / q.w; // ÂÉèÁ¥†Âú®ÊëÑÂÉèÊú∫ÂùêÊ†áÁ≥ª‰∏ãÁöÑ‰ΩçÁΩÆ
            bool lit = (fragment.z < -100 || // ËÉåÊôØÔºåÁõ¥Êé•‰∫Æ
                        (p.x < 0 || p.x >= shadoww || p.y < 0 || p.y >= shadowh) || // Ë∂ÖÂá∫ shadow map ËåÉÂõ¥
                        (p.z > zbuffer[int(p.x) + int(p.y) * shadoww] - .03)); // ÁÇπÊØî shadowmap Êõ¥Èù†ËøëÂÖâÊ∫ê => ÂèóÂÖâÁÖß
            // -0.03 ÊòØ‰∏Ä‰∏™ biasÔºåÈò≤Ê≠¢ z-fighting
            // p.z <= shadowmap_depth + bias ‚Üí ÁÇπÊØî shadowmap Êõ¥Ëøú ‚Üí Âú®Èò¥ÂΩ±Èáå
            // p.z ÁöÑÊñπÂêëÊòØ: Ë∂äÂ§ßË∂äÈù†ËøëÁõ∏Êú∫
            mask[x + y * width] = lit;
        }
    }

    TGAImage maskimg(width, height, TGAImage::GRAYSCALE);
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            if (mask[x + y * width]) continue;
            // Èò¥ÂΩ±ÁöÑÂú∞ÊñπÊòæÁ§∫ÁôΩËâ≤
            maskimg.set(x, y, {255, 255, 255, 255});
        }
    }
    maskimg.write_tga_file("mask.tga");

    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            if (mask[x + y * width]) continue; // ‰∫ÆÁÇπ‰∏çÂ§ÑÁêÜ
            // Èò¥ÂΩ±ÁÇπÂ§ÑÁêÜ
            TGAColor c = framebuffer.get(x, y);
            vec3 a = {static_cast<double>(c[0]), static_cast<double>(c[1]),
                      static_cast<double>(c[2])};
            if (norm(a) < 80) continue;
            a = normalized(a) * 80; // È¢úËâ≤ÂèòÊöó
            framebuffer.set(x, y, {(uint8_t) a[0], (uint8_t) a[1], (uint8_t) a[2], 255});
        }
    }
    framebuffer.write_tga_file("shadow.tga");

    return 0;
}

```
---
# üåë Èò¥ÂΩ±Ê∏≤Êüì‰ª£Á†ÅÁ¨îËÆ∞ÔºàShadow MappingÔºâ

Ëøô‰ªΩ‰ª£Á†ÅÂÆûÁé∞‰∫Ü‰∏Ä‰∏™ÁªèÂÖ∏ÁöÑ **Shadow Mapping Èò¥ÂΩ±Ê∏≤ÊüìÊµÅÁ®ã**ÔºåÊï¥‰ΩìÂàÜ‰∏∫‰∏âÊ≠•Ôºö

1. **ÊôÆÈÄöÊ∏≤ÊüìÔºàCamera passÔºâ**
    ‰ªéÁõ∏Êú∫ËßÜËßíÊ∏≤ÊüìÂú∫ÊôØÔºåÂæóÂà∞È¢úËâ≤ÂõæÂíåÁõ∏Êú∫Ê∑±Â∫¶„ÄÇ
2. **Èò¥ÂΩ±Ë¥¥ÂõæÁîüÊàêÔºàShadow map pass / Light passÔºâ**
    ‰ªéÂÖâÊ∫êËßÜËßíÊ∏≤ÊüìÂú∫ÊôØÔºåÂæóÂà∞ÂÖâÊ∫êÊ∑±Â∫¶ÂõæÔºàshadow mapÔºâ„ÄÇ
3. **ÂêéÂ§ÑÁêÜÂà§Êñ≠ÔºàPost-processÔºâ**
    ÂØπÊØè‰∏™Áõ∏Êú∫ÂÉèÁ¥†ÔºåÂèçÂèòÊç¢ÂõûÁõ∏Êú∫Á©∫Èó¥ ‚Üí ÊäïÂΩ±Âà∞ÂÖâÊ∫êÁ©∫Èó¥ ‚Üí Âíå shadow map Ê∑±Â∫¶ÊØîËæÉ ‚Üí Âà§Êñ≠ÊòØÂê¶Âú®Èò¥ÂΩ±Èáå„ÄÇ

------

## 1Ô∏è‚É£ ÊôÆÈÄöÊ∏≤Êüì pass

```cpp
lookat(eye, center, up);                     // Áõ∏Êú∫ËßÜËßíÁü©Èòµ
init_perspective(norm(eye - center));        // ÈÄèËßÜÊäïÂΩ±Áü©Èòµ
init_viewport(...);                          // ËßÜÂè£Áü©Èòµ
init_zbuffer(width, height);                 // ÂàùÂßãÂåñ z-buffer
TGAImage framebuffer(width, height, TGAImage::RGB);
```

- ËÆæÁΩÆÁõ∏Êú∫ÁöÑ ModelView„ÄÅPerspective„ÄÅViewport„ÄÇ
- ÂàùÂßãÂåñÁõ∏Êú∫ z-buffer„ÄÇ
- `framebuffer` ‰øùÂ≠òÊúÄÁªàÈ¢úËâ≤„ÄÇ

ÁÑ∂ÂêéÊ∏≤Êüì‰∏§‰∏™Ê®°ÂûãÔºö

```cpp
Model model_head("../Obj/diablo3_pose.obj");
Model model_floor("../Obj/floor.obj");

BlinnPhongShader shader(light_dir, eye, model_head);
for (faces in head) rasterize(...);

BlinnPhongShader shader(light_dir, eye, model_floor);
for (faces in floor) rasterize(...);
```

üëâ ÂæóÂà∞Ôºö

- **framebuffer** = ÂΩ©Ëâ≤Ê∏≤ÊüìÂõæÔºàBlinn-Phong ÂÖâÁÖßÔºâ„ÄÇ
- **zbuffer** = Áõ∏Êú∫ËßÜËßí‰∏ãÁöÑÊ∑±Â∫¶Âõæ„ÄÇ

------

## 2Ô∏è‚É£ Èò¥ÂΩ±Ë¥¥ÂõæÁîüÊàêÔºàÂÖâÊ∫êËßÜËßíÔºâ

È¶ñÂÖà‰øùÂ≠òÁõ∏Êú∫Áü©ÈòµÁöÑÈÄÜÁü©ÈòµÔºö

```cpp
mat<4,4> M = (Viewport * Perspective * ModelView).invert();
```

- ‰ª•ÂêéË¶ÅÁî®ÂÆÉÊääÂ±èÂπïÂÉèÁ¥†ÂùêÊ†á **ÂèçÂèòÊç¢ÂõûÁõ∏Êú∫Á©∫Èó¥**„ÄÇ

ÁÑ∂ÂêéÂàáÊç¢Âà∞ÂÖâÊ∫êËßÜËßíÔºö

```cpp
lookat(light_dir, center, up);             // ÂÖâÊ∫êËßÜËßí
init_perspective(norm(light_dir - center));
init_viewport(...);
init_zbuffer(shadoww, shadowh);
```

Ê∏≤ÊüìÂú∫ÊôØÔºå‰ΩÜËøôÈáåÁî® **BlankShader**Ôºö

```cpp
BlankShader shader{model_head};  // ‰∏çËÆ°ÁÆóÂÖâÁÖßÔºåÂè™ÂÜôÊ∑±Â∫¶
for (faces in head) rasterize(...);

BlankShader shader{model_floor};
for (faces in floor) rasterize(...);
```

- `BlankShader` ÁöÑ fragment ÊÄªÊòØÁôΩËâ≤ ‚Üí È¢úËâ≤Ê≤°ÊÑè‰πâ„ÄÇ
- ‰ΩÜÊòØ rasterizer ÂÜôÂÖ•ÁöÑ **zbuffer** Â∞±ÊòØÂÖâÊ∫êËÉΩÁúãÂà∞ÁöÑÊ∑±Â∫¶„ÄÇ

üëâ ÂæóÂà∞Ôºö

- `zbuffer` = **shadow map**ÔºàÂÖâÊ∫êËßÜËßí‰∏ãÁöÑÊ∑±Â∫¶ÂõæÔºâ„ÄÇ
- ‰øùÂ≠ò‰∏∫ `shadowmap.tga` Âíå `zbuffer2.tga`„ÄÇ

------

## 3Ô∏è‚É£ ÂêéÂ§ÑÁêÜÔºàÈò¥ÂΩ±Âà§ÂÆöÔºâ

ÂÖ≥ÈîÆÈÄªËæëÔºö

```cpp
mat<4,4> N = Viewport * Perspective * ModelView; // ÂÖâÊ∫êÁöÑÊäïÂΩ±Áü©Èòµ
```

### (a) Â±èÂπïÂÉèÁ¥† ‚Üí Áõ∏Êú∫Á©∫Èó¥ÂùêÊ†á

```cpp
vec4 fragment = M * vec4{x, y, zbuffer_copy[x+y*width], 1.};
```

- `(x,y)` = ÂΩìÂâçÂÉèÁ¥†‰ΩçÁΩÆ
- `zbuffer_copy[...]` = Áõ∏Êú∫ pass ‰∏ãËØ•ÂÉèÁ¥†ÁöÑÊ∑±Â∫¶
- ‰πò‰ª• `M = (VP*MV)^-1` = ‰ªéÂ±èÂπï ‚Üí Áõ∏Êú∫Á©∫Èó¥ÂùêÊ†á

------

### (b) Áõ∏Êú∫Á©∫Èó¥ ‚Üí ÂÖâÊ∫êÊäïÂΩ±ÂùêÊ†á

```cpp
vec4 q = N * fragment;
vec3 p = q.xyz() / q.w; 
```

- `N` = ÂÖâÊ∫êÁöÑÊäïÂΩ±Áü©Èòµ (Viewport * Perspective * ModelView)
- ÂæóÂà∞ `p = (p.x, p.y, p.z)`Ôºö
  - `p.x, p.y` ‚Üí Âú® shadow map ‰∏äÁöÑÂùêÊ†á
  - `p.z` ‚Üí ÂΩìÂâçÂÉèÁ¥†Âú®**ÊëÑÂÉèÊú∫ÂùêÊ†áÁ≥ª**‰∏ãÁöÑÊ∑±Â∫¶

------

### (c) ‰∏é shadow map ÊØîËæÉ

```cpp
bool lit = (fragment.z < -100 ||                    // ËÉåÊôØÁõ¥Êé•‰∫Æ
            (p.x<0 || p.x>=shadoww || p.y<0 || p.y>=shadowh) || // Ë∂ÖÂá∫shadowmapËåÉÂõ¥ ‚Üí ‰∫Æ
            (p.z > zbuffer[int(p.x)+int(p.y)*shadoww] - .03));  // Ê∑±Â∫¶ÊØîËæÉ
```

Ëß£ÈáäÔºö

- Â¶ÇÊûúÊòØËÉåÊôØ ‚Üí ‰∫Æ
- Â¶ÇÊûúË∂ÖÂá∫ shadow map ËåÉÂõ¥ ‚Üí ‰∫Æ
- Âê¶ÂàôÔºö
  - `shadowmap_depth = zbuffer[...]`
  - **Á∫¶ÂÆöÔºö‰Ω†ÁöÑÂùêÊ†áÁ≥ªÈáå p.z Ë∂äÂ§ßË∂äÈù†ËøëÂÖâÊ∫ê**
  - Ëã• `p.z > shadowmap_depth - bias` ‚Üí ÁÇπÊØî shadowmap ËÆ∞ÂΩïÁöÑÊõ¥Èù†ËøëÂÖâÊ∫ê ‚Üí ÂèØËßÅÔºà‰∫ÆÔºâ
  - Âê¶Âàô ‚Üí Ë¢´Êå°‰ΩèÔºàÈò¥ÂΩ±ÈáåÔºâ
  - `bias` Áî®‰∫éÈò≤Ê≠¢ **z-fighting**

üëâ `lit` = ÊòØÂê¶ÂèóÂÖâÁÖß

------

### (d) Èò¥ÂΩ±Ê†áËÆ∞‰∏éÂêéÂ§ÑÁêÜ

1. ÁîüÊàê mask ÂõæÔºö

   ```cpp
   if (!lit) maskimg.set(x,y,{255,255,255,255});
   ```

   Èò¥ÂΩ±Âå∫ÂüüÊòæÁ§∫ÁôΩËâ≤„ÄÇ

2. Ë∞ÉÊöóÈò¥ÂΩ±Âå∫ÂüüÔºö

   ```cpp
   if (!lit) {
       vec3 a = {c[0], c[1], c[2]};
       if (norm(a) >= 80) {
           a = normalized(a) * 80;   // Âéã‰Ωé‰∫ÆÂ∫¶
           framebuffer.set(x,y,{a[0],a[1],a[2],255});
       }
   }
   ```

   üëâ ÂæóÂà∞Â∏¶Èò¥ÂΩ±ÁöÑ `shadow.tga`„ÄÇ

------

# üìå ÊÄªÁªìÁ¨îËÆ∞

1. **ÊôÆÈÄöÊ∏≤Êüì pass**ÔºöÁõ∏Êú∫ËßÜËßíÊ∏≤ÊüìÔºåÂæóÂà∞È¢úËâ≤ + Ê∑±Â∫¶„ÄÇ
2. **Èò¥ÂΩ±Ë¥¥Âõæ pass**ÔºöÂÖâÊ∫êËßÜËßíÊ∏≤ÊüìÔºåÂæóÂà∞ shadow mapÔºàÊ∑±Â∫¶ÂõæÔºâ„ÄÇ
3. **ÂêéÂ§ÑÁêÜ**Ôºö
   - Áõ∏Êú∫ÂÉèÁ¥† ‚Üí Áõ∏Êú∫Á©∫Èó¥
   - Áõ∏Êú∫Á©∫Èó¥ ‚Üí ÂÖâÊ∫êÁ©∫Èó¥
   - Ê∑±Â∫¶ÊØîËæÉÔºö
     - `p.z > shadowmap_depth - bias` ‚Üí **ÂèóÂÖâÁÖß**
     - Âê¶Âàô ‚Üí **Âú®Èò¥ÂΩ±‰∏≠**
4. **ËæìÂá∫**Ôºö
   - framebuffer.tgaÔºàÁõ∏Êú∫Ê∏≤ÊüìÔºâ
   - zbuffer1.tgaÔºàÁõ∏Êú∫Ê∑±Â∫¶Ôºâ
   - shadowmap.tga / zbuffer2.tgaÔºàÂÖâÊ∫êÊ∑±Â∫¶Ôºâ
   - mask.tgaÔºàÈò¥ÂΩ±Âå∫ÂüüÔºâ
   - shadow.tgaÔºàÊúÄÁªàÂ∏¶Èò¥ÂΩ±ÊïàÊûúÁöÑÂõæÔºâ
