如下代码展示了三角形光栅化从 **画边** → **逐行扫描填充** → **重心坐标 (Barycentric coordinates)** 的逐步演化。下面我会 **逐个函数解释**，最后重点推导重心坐标的公式。

---

## 1. `triangle` (第一个版本) ―― **只画轮廓**

```cpp
// 绘制三角形的轮廓
void triangle(int ax, int ay, int bx, int by, int cx, int cy, TGAImage &framebuffer, TGAColor color) {
    if (ay > by) { std::swap(ax, bx); std::swap(ay, by); }
    if (ay > cy) { std::swap(ax, cx); std::swap(ay, cy); }
    if (by > cy) { std::swap(bx, cx); std::swap(by, cy); }
    line(ax, ay, bx, by, framebuffer, green);
    line(bx, by, cx, cy, framebuffer, green);
    line(cx, cy, ax, ay, framebuffer, red);
}
```

### 思路

1. **冒泡排序**：按 `y` 从小到大排序顶点，保证顺序一致。
2. **画线**：分别调用 `line`，画三条边。

这个版本只是画出三角形的**轮廓线框**。

---

## 2. `triangle` (第二个版本) ―― **逐行扫描填充**

```cpp
void triangle(int ax, int ay, int bx, int by, int cx, int cy, TGAImage &framebuffer, TGAColor color) {
    // 冒泡排序，根据y坐标从小到大排序三个顶点
    if (ay > by) { std::swap(ax, bx); std::swap(ay, by); }
    if (ay > cy) { std::swap(ax, cx); std::swap(ay, cy); }
    if (by > cy) { std::swap(bx, cx); std::swap(by, cy); }

    int total_height = cy - ay;

    // 下半部分
    if (ay != by) {
        int segment_height = by - ay; // 下半部分的高度
        for (int y = ay; y <= by; y++) {
            int x1 = ax + ((cx - ax) * (y - ay)) / total_height;
            int x2 = ax + ((bx - ax) * (y - ay)) / segment_height;
            for(int x = std::min(x1, x2); x <= std::max(x1, x2); x++) {
                framebuffer.set(x, y, color);
            }
        }
    }

    // 上半部分
    if (by != cy) {
        int segment_height = cy - by; // 上半部分的高度
        for (int y = by; y <= cy; y++) {
            int x1 = ax + ((cx - ax) * (y - ay)) / total_height;
            int x2 = bx + ((cx - bx) * (y - by)) / segment_height;
            for (int x = std::min(x1, x2); x <= std::max(x1, x2); x++) {
                framebuffer.set(x, y, color);
            }
        }
    }
}
```

### 思路

1. 把三角形按 y 排序：A (最低)、B (中间)、C (最高)。
2. **拆分成上下两个梯形**：

    * A-B-C（下半部分：A→B 边和 A→C 边）
    * B-C-A（上半部分：B→C 边和 A→C 边）
3. 扫描线填充：

    * 对每个 y，分别算出左边交点 x1、右边交点 x2，画水平线。

这是经典的“扫描线三角形填充”方法。

---

## 3. `signed_triangle_area` ―― **带符号的三角形面积**

```cpp
double signed_triangle_area(int ax, int ay, int bx, int by, int cx, int cy) {
    return .5 * ((by - ay) * (bx + ax) + (cy - by) * (cx + bx) + (ay - cy) * (ax + cx));
}
```

### 数学背景

**三角形面积公式**的另一种形式：
$$
S = \frac{1}{2} |(x_1y_2 - x_2y_1) + (x_2y_3 - x_3y_2) + (x_3y_1 - x_1y_3)|
$$

等价于向量叉积：

$$
S = \frac{1}{2} |(B-A) \times (C-A)|
$$

这段代码是叉积形式的展开，并**保留符号**：

* 面积可能是正的或负的，取决于顶点顺序（顺时针/逆时针）。
* 符号信息在 **重心坐标计算** 时很有用。

---

## 4. `triangle` (最终版本) ―― **重心坐标 (Barycentric coordinates) 填充**

```cpp
void triangle(int ax, int ay, int bx, int by, int cx, int cy, TGAImage &framebuffer, TGAColor color) {
    // 计算AABB轴对齐包围盒
    int bbminx = std::min(std::min(ax, bx), cx);
    int bbminy = std::min(std::min(ay, by), cy);
    int bbmaxx = std::max(std::max(ax, bx), cx);
    int bbmaxy = std::max(std::max(ay, by), cy);

    double total_area = signed_triangle_area(ax, ay, bx, by, cx, cy);

    // 遍历包围盒内的所有像素，根据重心坐标判断是否在三角形内部，如果在，就绘制这个像素，否则就忽略它
    #pragma omp parallel for
    for (int x = bbminx; x <= bbmaxx; x++) {
        for (int y = bbminy; y <= bbmaxy; y++) {
            double alpha = signed_triangle_area(x, y, bx, by, cx, cy) / total_area;
            double beta  = signed_triangle_area(x, y, cx, cy, ax, ay) / total_area;
            double gamma = signed_triangle_area(x, y, ax, ay, bx, by) / total_area;

            if (alpha < 0 || beta < 0 || gamma < 0) continue;
            framebuffer.set(x, y, color);
        }
    }
}
```

### 思路

1. **计算包围盒 (AABB)**：
   找出三角形的最小矩形区域，减少遍历范围。

2. **重心坐标 (Barycentric coordinates)**：
   对于点 P(x,y)，计算它相对于三角形 ABC 的坐标 `(α, β, γ)`：

    * α = 面积(PBC) / 面积(ABC)
    * β = 面积(PCA) / 面积(ABC)
    * γ = 面积(PAB) / 面积(ABC)

   直观理解：重心坐标表示“点 P 在三角形里的权重分配”。

3. **判断点是否在三角形内**：

    * 如果 α, β, γ 都 ≥ 0，说明点 P 在三角形内部。
    * 否则 P 在三角形外。

4. **填充像素**：
   在包围盒内的点，凡是落在三角形内，就着色。

---

## 5. 重心坐标推导

### 定义

对于**三角形 ABC 内的点 P**，重心坐标 (α, β, γ) 满足：

$$
P = \alpha A + \beta B + \gamma C, \quad \alpha+\beta+\gamma=1, \quad \alpha,\beta,\gamma \ge 0
$$

### 推导（面积法）

1. 设三角形总面积为：

   $$
   S = \text{Area}(ABC)
   $$

2. 定义：

    * α = Area(PBC) / S
    * β = Area(PCA) / S
    * γ = Area(PAB) / S

3. 性质：

    * α+β+γ = (Area(PBC)+Area(PCA)+Area(PAB)) / S = S/S = 1
    * 如果 P 在三角形内部，三块小三角形的面积都 ≥ 0，所以 α, β, γ ≥ 0。
    * 如果 P 在外部，至少有一个是负的。

所以可以用面积比来快速判断点是否在三角形内部，同时得到重心坐标。

---

## 总结

* **第一个 `triangle`**：只画边。
* **第二个 `triangle`**：扫描线法，逐行填充。
* **`signed_triangle_area`**：计算三角形面积（带符号，用于区分方向）。
* **最后一个 `triangle`**：使用 **重心坐标 (barycentric coordinates)**，在包围盒内遍历像素，判断是否落在三角形里并填充。

**重心坐标**推导公式：
$$
\alpha = \frac{Area(PBC)}{Area(ABC)}, \quad
\beta = \frac{Area(PCA)}{Area(ABC)}, \quad
\gamma = \frac{Area(PAB)}{Area(ABC)}
$$



---

判断一个点是否在三角形内部，常见的做法有三种：

1. **重心坐标（面积比法）**
2. **向量叉积法**
3. **向量点积法（同向性 / 角度法）**

代码里用的是 **重心坐标（面积比）**，而不是直接用叉乘或点乘。我们来对比一下。

---

## 1. 叉乘法 (Cross Product)

设三角形顶点 $A,B,C$，点为 $P$。
向量叉积可以判断两个向量的相对方向（左/右），因为叉积结果的 **符号** 表示方向。

公式：

$$
cross(AB, AP),\ cross(BC, BP),\ cross(CA, CP)
$$

* 如果这三个叉积的符号相同（都 ≥ 0 或都 ≤ 0），说明点 P 在三角形内部；
* 如果有一个不同，点 P 在外部。

**优点**：

* 不需要除法，效率高。
* 只要比较符号，非常适合整数运算（光栅化硬件常用）。

**缺点**：

* 如果需要进一步计算插值（比如插颜色、纹理坐标、深度），叉积法只能给“inside/outside”布尔结果，不能直接给出权重。

---

## 2. 点乘法 (Dot Product)

点积可以判断夹角是否锐角/钝角，也能用来判断点是否在三角形内部。

方法一：判断点是否在每条边的“同侧”。

* 比如要判断 P 是否在 AB 边的内侧，可以看：

  $$
  dot(n_{AB}, P-A) \quad \text{与} \quad dot(n_{AB}, C-A)
  $$

  是否符号相同，其中 $n_{AB}$ 是 AB 的法向量。

**优点**：

* 思路直观，几何意义清晰。

**缺点**：

* 仍然只能给 inside/outside 布尔值，不直接提供插值权重。

---

## 3. 重心坐标法 (Barycentric Coordinates)

代码里用的是面积比（叉积的几何意义）。

$$
\alpha = \frac{Area(PBC)}{Area(ABC)},\
\beta = \frac{Area(PCA)}{Area(ABC)},\
\gamma = \frac{Area(PAB)}{Area(ABC)}
$$

* 判断内部性：只要 $\alpha,\beta,\gamma \ge 0$，说明点在三角形内部。
* **额外好处**：$(\alpha, \beta, \gamma)$ 本身就是插值权重！

   * 可以用来插值颜色、纹理坐标、深度值 (Z-buffer)。
   * 例如：

     $$
     color(P) = \alpha \cdot color(A) + \beta \cdot color(B) + \gamma \cdot color(C)
     $$

---

## 4. 为什么代码里不用单纯的叉乘/点乘？

因为这段代码不仅要判断 inside/outside，还要为后续 **光栅化 + 插值** 提供重心坐标。

* 如果只是判断内部，叉积法更快。
* 但如果你要做 **着色 (shading)、纹理映射 (texturing)、深度测试 (z-buffer)**，就必须要有 $\alpha, \beta, \gamma$。
* 重心坐标法 **一步到位**：既能判断 inside/outside，又能得到权重。

---

## 总结

* **叉乘法**：只判断 inside/outside，快，但没权重。
* **点乘法**：几何直观，也只判断 inside/outside。
* **重心坐标法**：同时得到 inside/outside + 插值权重，是光栅化和渲染的核心。

所以在软件渲染器（TinyRenderer、OpenGL pipeline）里，几乎都会用 **重心坐标**。
