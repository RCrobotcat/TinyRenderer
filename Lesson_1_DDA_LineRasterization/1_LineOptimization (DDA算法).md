这里展示的是「逐步优化直线光栅化」的过程，从最朴素的插值采样，一点点优化，直到处理所有情况。下面我帮你把每个版本的代码和优化逻辑 **详细拆解**。

---

# 🌟 总体目标

我们要在二维像素栅格里，用整数像素点去近似绘制一条从 `(ax, ay)` 到 `(bx, by)` 的直线。

由于像素是离散的，而直线是连续的，所以必须用某种插值方式去“采样”直线，选择合适的像素点。
优化的目标是：

1. 覆盖整条直线，不留断点。
2. 适配各种情况（水平、竖直、斜率大/小）。
3. 效率尽量高。

---

# 🔹 初始版（最简单的采样版）

```cpp
for (float t = 0.; t < 1.; t += .02) {
    int x = std::round(ax + (bx - ax) * t);
    int y = std::round(ay + (by - ay) * t);
    framebuffer.set(x, y, color);
}
```

### 思路

* 用参数 `t ∈ [0, 1]` 来插值：

  * `(x, y) = (ax + (bx - ax)*t, ay + (by - ay)*t)`。
* 每次增加 `t` 一小步，相当于在直线上均匀采样。
* 再四舍五入到最近像素格。

### 问题

* `t += 0.02` 是**固定步长**，如果直线很长，点与点之间会有“断裂”；
* 如果直线很短，就会重复落到同一个像素上；
* 不保证覆盖所有像素（有时线段看起来“稀疏”）。

👉 这个版本只能算“演示思路”，实际效果不好。

---

# 🔹 优化版 1（以 `x` 为主变量）

```cpp
for (int x = ax; x <= bx; x++) {
    float t = (x - ax) / static_cast<float>(bx - ax);
    int y = std::round(ay + (by - ay) * t);
    framebuffer.set(x, y, color);
}
```

### 思路

* 不再用 `t += 0.02` 固定采样，而是**直接遍历每个像素列（x 轴整数点）**。
* 对每个 `x`，用插值公式算出对应的 `y`。

### 改进点

* 保证了直线在 **横向方向上是连续的**（每个整数 x 都会画一个点）。
* 解决了初始版“点稀疏”的问题。

### 问题

1. **只适用于 `ax <= bx`**，否则循环不会执行（直线“消失”）。
2. 如果斜率很大（竖直或接近竖直），y 变化很快，可能有些像素行没被覆盖（直线看起来“断裂”）。

---

# 🔹 优化版 2（保证从左到右）

```cpp
if (ax > bx) {
    std::swap(ax, bx);
    std::swap(ay, by);
}
for (int x = ax; x <= bx; x++) {
    float t = (x - ax) / static_cast<float>(bx - ax);
    int y = std::round(ay + (by - ay) * t);
    framebuffer.set(x, y, color);
}
```

### 思路

* 增加了一步：如果起点在右边，就交换两个端点，保证从左往右画。

### 改进点

* 解决了“`ax > bx` 时循环不执行”的问题。
* 不论传入点的顺序如何，都能画出直线。

### 问题

* 仍然没有解决\*\*斜率大于 1（陡直线）\*\*时“断裂”的问题。

---

# 🔹 优化版 3（处理陡直线：steep 技巧）

```cpp
bool steep = std::abs(ax - bx) < std::abs(ay - by);
if (steep) {
    std::swap(ax, ay);
    std::swap(bx, by);
}
if (ax > bx) {
    std::swap(ax, bx);
    std::swap(ay, by);
}
for (int x = ax; x <= bx; x++) {
    float t = (x - ax) / static_cast<float>(bx - ax);
    int y = std::round(ay + (by - ay) * t);
    if (steep)
        framebuffer.set(y, x, color); // de-transpose
    else
        framebuffer.set(x, y, color);
}
```

### 思路

1. 判断直线是否陡峭：

   * 如果 `|dy| > |dx|`，即竖直方向跨度更大，就称为“steep”。
   * 在这种情况下，x 递增不合适，容易漏点。
   * 解决办法：**交换 x 和 y 的角色**（相当于转置画布）。

2. 画完之后再把坐标“交换回来”（de-transpose）。

### 改进点

* 即使斜率大于 1，也能保证直线连续，不会出现断裂或消失。
* 现在已经能正确绘制所有情况的直线。

---

# 🔥 总结对比

| 版本    | 思路              | 优点         | 缺点                         |
|-------|-----------------|------------|----------------------------|
| 初始版   | 均匀采样 `t`        | 简单易懂       | 步长固定，点稀疏或重叠，线可能断           |
| 优化版 1 | 遍历 x，插值 y       | 横向连续       | 只适用于 `ax <= bx`；斜率大时会断裂    |
| 优化版 2 | 保证左到右           | 不受点顺序影响    | 斜率大时仍断裂                    |
| 优化版 3 | steep 技巧，x/y 转置 | 所有斜率都能正确绘制 | 仍用浮点运算，性能不够高（Bresenham 更优） |

---

👉 你现在的 **优化版 3** 就是一个标准的 **DDA（Digital Differential Analyzer）直线算法** 的变体，能够覆盖所有情况。
👉 再往后优化的话，就是 **Bresenham 算法** —— 全部用整数运算，效率更高。
